@page "/protocols"

@using SIP.UI.Components.Dialogs.Protocols
@using SIP.UI.Domain.DTOs.Protocols.Responses
@using SIP.UI.Domain.Enums
@using SIP.UI.Domain.Helpers.DataFormatting.Strings
@using SIP.UI.Domain.Services.Protocols
@using SIP.UI.Models.Protocols
@using SIP.UI.Models.Users
@using SIP.UI.Models.Sectors
@using MudBlazor
@using MudBlazor.Utilities

@inject ProtocolService _protocolService
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<MudContainer MaxWidth="MaxWidth.Large" Class="my-8 px-4">

    <MudStack Row="true" AlignItems="AlignItems.Stretch" Class="mb-3 ml-3">
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ShowAddDialog" Class="@GetButtonClass()">
            <MudIcon Icon="@Icons.Material.Filled.Add" Size="Size.Medium" />
            <span class="button-text-label">Novo Protocolo</span>
        </MudButton>
    </MudStack>

    <MudPaper Class="pa-4 ma-2" Elevation="1">

        <MudTable T="ProtocolListItemDto" ServerData="LoadServerData" Dense="true" Hover="true" Bordered="false" @ref="table" RowsPerPage="pageSize" LoadingProgressColor="Color.Primary" Loading="@isLoading" Elevation="0" MultiSelection="true" @bind-SelectedItems="_selectedProtocols">

            <ToolBarContent>

                <MudStack Style="width: 100%; margin-left: -0.75rem;" Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">

                    <MudStack Row="true" AlignItems="AlignItems.Center">

                        @if (_selectedProtocols.Any())
                        {
                            <MudTooltip Text="@($"Ações aplicáveis para {_selectedProtocols.Count} protocolo(s) selecionado(s)")" Arrow="true" Placement="Placement.Bottom">

                                <MudMenu Dense="true" Icon="@Icons.Material.Filled.SettingsApplications" Color="Color.Primary" AnchorOrigin="Origin.BottomRight" TransformOrigin="Origin.TopRight">

                                    @if (_selectedProtocols.Count == 1)
                                    {
                                        <MudMenuItem OnClick="@EditSelectedProtocol">
                                            <MudStack Row="true" AlignItems="AlignItems.Center">
                                                <MudIcon Icon="@Icons.Material.Filled.Edit" Size="Size.Small" />
                                                <MudText Typo="Typo.body2">Editar</MudText>
                                            </MudStack>
                                        </MudMenuItem>
                                        <MudDivider Class="my-2" />
                                        <MudMenuItem OnClick="@(() => ShowDeleteDialog(_selectedProtocols.First()))" Style="color: var(--mud-palette-error);">
                                            <MudStack Row="true" AlignItems="AlignItems.Center">
                                                <MudIcon Icon="@Icons.Material.Filled.Delete" Size="Size.Small" />
                                                <MudText Typo="Typo.body2">Excluir</MudText>
                                            </MudStack>
                                        </MudMenuItem>
                                    }
                                    @if (_selectedProtocols.Count > 1)
                                    {
                                        <MudMenuItem OnClick="ShowDeleteSelectedProtocolsDialog" Style="color: var(--mud-palette-error);">
                                            <MudStack Row="true" AlignItems="AlignItems.Center">
                                                <MudIcon Icon="@Icons.Material.Filled.Delete" Size="Size.Small" />
                                                <MudText Typo="Typo.body2">Excluir</MudText>
                                            </MudStack>
                                        </MudMenuItem>
                                    }
                                </MudMenu>

                            </MudTooltip>
                        }
                    </MudStack>

                    <MudStack Row="true" AlignItems="AlignItems.Center">

                        <MudTextField T="string" ValueChanged="@OnSearch" Immediate="false" DebounceInterval="300" Placeholder="digite sua busca..." Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="m-auto" Clearable="true" Style="max-width: 300px;" />

                        <MudTooltip Text="Exportar para formatos compatíveis ..." Arrow="true" Placement="Placement.Bottom">
                            <MudMenu Icon="@Icons.Material.Filled.MoreVert" Color="Color.Primary" AnchorOrigin="Origin.BottomRight" TransformOrigin="Origin.TopRight">
                                <MudMenuItem OnClick="ExportToCsv">Exportar CSV</MudMenuItem>
                                <MudMenuItem OnClick="ExportToPdf">Exportar PDF</MudMenuItem>
                            </MudMenu>
                        </MudTooltip>

                    </MudStack>

                </MudStack>

            </ToolBarContent>

            <HeaderContent>

                <MudTh Class="mud-table-header-custom px-0 py-0" Style="width: 10px;"></MudTh>
                <MudTh Class="mud-table-header-custom">
                    <MudTableSortLabel InitialDirection="SortDirection.Ascending" SortBy="new Func<ProtocolListItemDto, object>(p => p.Status)">Status</MudTableSortLabel>
                </MudTh>
                <MudTh Class="mud-table-header-custom">
                    <MudTableSortLabel SortLabel="number" SortBy="new Func<ProtocolListItemDto, object>(p => p.Number!)">Número</MudTableSortLabel>
                </MudTh>
                <MudTh Class="mud-table-header-custom">
                    <MudTableSortLabel SortLabel="CreatedBy" SortBy="new Func<ProtocolListItemDto, object>(p => p.CreatedByFullName!)">Criado Por</MudTableSortLabel>
                </MudTh>
                <MudTh Class="mud-table-header-custom">
                    <MudTableSortLabel SortLabel="OriginSector" SortBy="new Func<ProtocolListItemDto, object>(p => p.OriginSectorAcronym!)">Setor Origem</MudTableSortLabel>
                </MudTh>
                <MudTh Class="mud-table-header-custom">
                    <MudTableSortLabel SortLabel="DestinationTo" SortBy="new Func<ProtocolListItemDto, object>(p => p.DestinationUserFullName!)">Destinado a</MudTableSortLabel>
                </MudTh>
                <MudTh Class="mud-table-header-custom">
                    <MudTableSortLabel SortLabel="DestinationSector" SortBy="new Func<ProtocolListItemDto, object>(p => p.DestinationSectorAcronym!)">Setor Destino</MudTableSortLabel>
                </MudTh>
                <MudTh Class="mud-table-header-custom">Assunto</MudTh>
                <MudTh Class="mud-table-header-custom">Descrição</MudTh>

            </HeaderContent>

            <RowTemplate Context="protocol">

                @* Nova célula para a coluna de arquivados *@
                <MudTd DataLabel="Arquivado" Class="px-0 py-0" Style="text-align: center;">
                    @if (protocol.IsArchived)
                    {
                        <MudTooltip Text="Arquivado...">
                            <MudIcon Icon="@Icons.Material.Filled.Archive" Style="color: #ABA9A9;" Size="Size.Small" />
                        </MudTooltip>
                    }
                    else
                    {
                        <MudTooltip Text="Não arquivado...">
                            <MudIcon Icon="@Icons.Material.Outlined.Archive" Style="color: #ABA9A9;" Size="Size.Small" />
                        </MudTooltip>
                    }
                </MudTd>

                <MudTd DataLabel="Status">@GetStatusChip(protocol.Status)</MudTd>

                <MudTd DataLabel="Número">@protocol.Number</MudTd>

                <MudTd Class="mud-table-cell-truncate" Style="max-width: 200px;" DataLabel="Criado Por">
                    <MudTooltip Text="@protocol.CreatedByFullName.ToUppercase()">
                        <span>@FormatName(protocol.CreatedByFullName.ToUppercase())</span>
                    </MudTooltip>
                </MudTd>

                <MudTd Class="mud-table-cell-truncate" Style="max-width: 120px;" DataLabel="Setor Origem">
                    <MudTooltip Text="@protocol.OriginSectorAcronym.ToUppercase()">
                        <span>@protocol.OriginSectorAcronym.ToUppercase()</span>
                    </MudTooltip>
                </MudTd>

                <MudTd Class="mud-table-cell-truncate" Style="max-width: 200px;" DataLabel="Destinado a">
                    <MudTooltip Text="@protocol.DestinationUserFullName.ToUppercase()">
                        <span>@FormatName(protocol.DestinationUserFullName.ToUppercase())</span>
                    </MudTooltip>
                </MudTd>

                <MudTd Class="mud-table-cell-truncate" Style="max-width: 120px;" DataLabel="Setor Destino">
                    <MudTooltip Text="@protocol.DestinationSectorAcronym.ToUppercase()">
                        <span>@protocol.DestinationSectorAcronym.ToUppercase()</span>
                    </MudTooltip>
                </MudTd>

                <MudTd Class="mud-table-cell-truncate" Style="max-width: 250px;" DataLabel="Assunto">
                    <MudTooltip Text="@protocol.Subject.ToUppercase()">
                        <span>@protocol.Subject.ToUppercase()</span>
                    </MudTooltip>
                </MudTd>

                <MudTd DataLabel="Descrição">
                    <MudTooltip Text="@TruncateText(protocol.Description!, 200)" Style="width: 15rem; padding: 0.5rem; white-space: normal; word-wrap: break-word; overflow-wrap: break-word; text-align: justify;">
                        <div class="truncate-cell">
                            @protocol.Description
                        </div>
                    </MudTooltip>

                </MudTd>

            </RowTemplate>

            <NoRecordsContent>
                <MudText Class="pa-6 text-center mud-text-secondary">Nenhum protocolo encontrado para exibir.</MudText>
            </NoRecordsContent>

            <LoadingContent>
                <MudText Class="pa-6 text-center mud-text-secondary">Carregando protocolos, por favor aguarde...</MudText>
            </LoadingContent>

            <PagerContent>
                <MudTablePager PageSizeOptions="new int[] { 15, 25, 50, 100 }" />
            </PagerContent>

        </MudTable>

    </MudPaper>

</MudContainer>

@code {
    private MudTable<ProtocolListItemDto>? table;
    private bool isLoading = false;
    private int pageSize = 15;
    private string searchString = string.Empty;
    private bool _isModalOpen = false;

    private HashSet<ProtocolListItemDto> _selectedProtocols = new();

    private RenderFragment GetStatusChip(ProtocolStatus status)
    {
        var (text, icon, color) = GetStatusDetails(status);
        return @<MudChip T="string" Label="true" Icon="@icon" Color="@color" Size="Size.Small" Class="rounded-md" Style="width: 6rem;justify-content: center;">@text</MudChip>;
    }

    private (string Text, string Icon, Color Color) GetStatusDetails(ProtocolStatus status) => status switch
    {
        ProtocolStatus.Open => ("Em Aberto", Icons.Material.Filled.FiberNew, Color.Primary),
        ProtocolStatus.SentForReview => ("Enviado", Icons.Material.Filled.Send, Color.Tertiary),
        ProtocolStatus.Received => ("Recebido", Icons.Material.Filled.MarkEmailRead, Color.Success),
        ProtocolStatus.UnderReview => ("Em Análise", Icons.Material.Filled.Search, Color.Warning),
        ProtocolStatus.Approved => ("Aprovado", Icons.Material.Filled.CheckCircle, Color.Success),
        ProtocolStatus.Rejected => ("Rejeitado", Icons.Material.Filled.Cancel, Color.Error),
        ProtocolStatus.CorrectionRequested => ("Correção", Icons.Material.Filled.Edit, Color.Warning),
        ProtocolStatus.Finalized => ("Finalizado", Icons.Material.Filled.DoneAll, Color.Dark),
        _ => ("Desconhecido", Icons.Material.Filled.HelpOutline, Color.Default)
    };

    private string GetButtonClass() =>
        $"mud-elevation-3 animated-fab-button-manual-icon {(_isModalOpen ? "force-expanded-button" : "")}";

    /// <summary>
    /// Trunca um texto para um comprimento máximo e adiciona "..." se necessário.
    /// Ideal para limitar o conteúdo de tooltips longos.
    /// </summary>
    /// <param name="text">O texto a ser truncado.</param>
    /// <param name="maxLength">O comprimento máximo desejado.</param>
    /// <returns>O texto truncado.</returns>
    private string TruncateText(string text, int maxLength = 200)
    {
        if (string.IsNullOrEmpty(text) || text.Length <= maxLength)
        {
            return text;
        }
        return text.Substring(0, maxLength) + "...";
    }

    /// <summary>
    /// Formata um nome completo para exibir apenas o primeiro e o último nome.
    /// </summary>
    /// <param name="fullName">O nome completo a ser formatado.</param>
    /// <returns>O nome formatado ou o nome original se a formatação não for possível.</returns>
    private string FormatName(string? fullName)
    {
        if (string.IsNullOrWhiteSpace(fullName))
            return string.Empty;

        var nameParts = fullName.Split(' ', StringSplitOptions.RemoveEmptyEntries);

        if (nameParts.Length == 1)
            return nameParts[0];

        // Sempre pega o primeiro nome
        var formattedName = nameParts[0];

        // Avança pelos próximos nomes
        for (int i = 1; i < nameParts.Length; i++)
        {
            var part = nameParts[i];

            // Se for partícula (palavra pequena), adiciona
            if (part.Length <= 3)
            {
                formattedName += $" {part}";
                continue;
            }

            // Se já pegou um sobrenome, para
            formattedName += $" {part}";
            break;
        }

        return formattedName;
    }

    protected override void OnInitialized() =>
        _selectedProtocols.Clear();

    private async Task<TableData<ProtocolListItemDto>> LoadServerData(TableState state, CancellationToken cancellationToken)
    {
        isLoading = true;
        StateHasChanged();

        _selectedProtocols.Clear();

        pageSize = state.PageSize;
        string? sortLabel = state.SortLabel;

        if (string.IsNullOrWhiteSpace(sortLabel))
            sortLabel = "Status";

        try
        {
            ProtocolPagedResultDTO protocols = await _protocolService.GetPagedProtocolsAsync(
                state.Page + 1,
                state.PageSize,
                sortLabel,
                GetSortDirectionString(state.SortDirection),
                searchString);

            return new TableData<ProtocolListItemDto>
            {
                Items = protocols.Items,
                TotalItems = protocols.TotalCount
            };
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Erro ao carregar dados: {ex.Message}", Severity.Error);
            return new TableData<ProtocolListItemDto> { Items = [], TotalItems = 0 };
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private string GetSortDirectionString(SortDirection direction) =>
        direction switch
        {
            SortDirection.Ascending => "asc",
            SortDirection.Descending => "desc",
            _ => string.Empty
        };

    private async Task OnSearch(string value)
    {
        searchString = value;
        if (table is not null)
            await table.ReloadServerData();
    }

    private async Task ShowAddDialog()
    {
        _isModalOpen = true;

        DialogParameters<ProtocolEditDialog> parameters = new();
        parameters.Add(x => x.Protocol, new Protocol { Id = Guid.Empty });
        IDialogReference dialog = await DialogService.ShowAsync<ProtocolEditDialog>(" ", parameters);
        DialogResult? result = await dialog.Result;

        _isModalOpen = false;

        if (result is not null && !result.Canceled)
        {
            Protocol? savedProtocol = result.Data as Protocol;

            if (savedProtocol != null)
            {
                try
                {
                    await _protocolService.CreateProtocolAsync(savedProtocol);
                    Snackbar.Add("Protocolo criado com sucesso!", Severity.Success);
                    if (table is not null)
                        await table.ReloadServerData();
                }
                catch (Exception ex)
                {
                    Snackbar.Add($"Erro ao criar protocolo: {ex.Message}", Severity.Error);
                }
            }
        }
        else
        {
            Snackbar.Add("Inserção de protocolo cancelada.", Severity.Info);
        }
    }

    private async Task ShowEditDialog(Protocol protocol)
    {
        _isModalOpen = true;

        DialogParameters<ProtocolEditDialog> parameters = new();
        parameters.Add(x => x.Protocol, protocol);

        IDialogReference dialog = await DialogService.ShowAsync<ProtocolEditDialog>(" ", parameters);
        DialogResult? result = await dialog.Result;

        _isModalOpen = false;

        if (result is not null && !result.Canceled)
        {
            Protocol? updatedProtocol = result.Data as Protocol;

            if (updatedProtocol != null)
            {
                try
                {
                    await _protocolService.UpdateProtocolAsync(updatedProtocol);
                    Snackbar.Add("Protocolo atualizado com sucesso!", Severity.Success);
                    if (table is not null)
                        await table.ReloadServerData();
                }
                catch (Exception ex)
                {
                    Snackbar.Add($"Erro ao atualizar protocolo: {ex.Message}", Severity.Error);
                }
            }
        }
        else
        {
            Snackbar.Add("Edição de protocolo cancelada.", Severity.Info);
        }
    }

    private async Task EditSelectedProtocol()
    {
        if (_selectedProtocols.Count != 1) return;

        var selectedProtocolDto = _selectedProtocols.First();
        isLoading = true;

        var fullProtocol = await _protocolService.GetProtocolByIdAsync(selectedProtocolDto.Id);

        isLoading = false;

        if (fullProtocol != null)
        {
            await ShowEditDialog(fullProtocol);
        }
        else
        {
            Snackbar.Add("Não foi possível carregar os dados do protocolo para edição.", Severity.Error);
        }
    }

    private async Task ShowDeleteDialog(ProtocolListItemDto protocolDto)
    {
        _isModalOpen = true;
        var parameters = new DialogParameters<ProtocolDeleteDialog>();
        parameters.Add(x => x.ProtocolToDelete, protocolDto);

        var dialog = await DialogService.ShowAsync<ProtocolDeleteDialog>(" ", parameters);
        var result = await dialog.Result;

        _isModalOpen = false;

        if (result is not null && !result.Canceled)
        {
            try
            {
                await _protocolService.DeleteProtocolAsync(protocolDto.Id);
                Snackbar.Add("Protocolo excluído com sucesso!", Severity.Success);

                if (table is not null)
                {
                    _selectedProtocols.Remove(protocolDto);
                    await table.ReloadServerData();
                }
            }
            catch (InvalidOperationException ex)
            {
                Snackbar.Add($"Erro ao excluir protocolo: {ex.Message}", Severity.Error);
            }
            catch (HttpRequestException ex)
            {
                Snackbar.Add($"Erro de comunicação: {ex.Message}", Severity.Error);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Ocorreu um erro inesperado: {ex.Message}", Severity.Error);
            }
        }
        else
        {
            Snackbar.Add("Exclusão de protocolo cancelada.", Severity.Info);
        }
    }

    private void ShowDeleteSelectedProtocolsDialog()
    {
        Snackbar.Add("A Exclusão de múltiplos registros ainda não foi implementada.", Severity.Info);
    }

    private void ExportToCsv()
    {
        Snackbar.Add("Exportação para CSV ainda não implementada.", Severity.Info);
    }

    private void ExportToPdf()
    {
        Snackbar.Add("Exportação para PDF ainda não implementada.", Severity.Info);
    }
}